import { PR_CONSTANTS } from "../utils/constants.js";
import { createLogger } from "../utils/logger.js";

const logger = createLogger("PRService");

export class PRService {
  constructor() {
    this.AUTO_SUMMARY_TAG = PR_CONSTANTS.AUTO_SUMMARY_TAG;
    this.SUMMARY_MARKER = PR_CONSTANTS.SUMMARY_MARKER;
    this.END_MARKER = PR_CONSTANTS.END_MARKER;
  }

  /**
   * Generate PR summary using GitHub Copilot API via the provided token
   */
  async generatePRSummary(pullRequest, diff, commits, githubToken) {
    try {
      logger.info(`Generating summary for PR: ${pullRequest.title}`);

      if (!githubToken) {
        throw new Error("GitHub token required for Copilot API");
      }

      // Create comprehensive prompt for PR analysis
      const prompt = this._createSummaryPrompt(pullRequest, diff, commits);

      // Use GitHub Copilot API directly
      const summary = await this._generateWithCopilot(prompt, githubToken);

      logger.info("Successfully generated PR summary using Copilot API");
      return summary;
    } catch (error) {
      logger.error("Failed to generate PR summary:", error.message);

      // Fall back to basic summary if Copilot fails
      logger.warn("Falling back to basic summary generation");
      return this._createFallbackSummary(pullRequest, commits);
    }
  }

  /**
   * Generate response using GitHub Copilot API
   */
  async _generateWithCopilot(prompt, githubToken) {
    const response = await fetch(
      "https://api.githubcopilot.com/chat/completions",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${githubToken}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          messages: [
            {
              role: "system",
              content:
                "You are a helpful assistant that analyzes code changes and generates clear, professional summaries and changelog entries. You understand conventional commits and can create well-structured changelogs. Focus on the impact and purpose of changes.",
            },
            {
              role: "user",
              content: prompt,
            },
          ],
          stream: false,
        }),
      }
    );

    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(
        `GitHub Copilot API error: ${response.status} ${response.statusText} - ${errorBody}`
      );
    }

    const data = await response.json();
    const generatedContent = data.choices[0]?.message?.content;

    if (!generatedContent) {
      throw new Error("No content generated by GitHub Copilot");
    }

    return generatedContent;
  }

  /**
   * Create a comprehensive prompt for PR analysis
   */
  _createSummaryPrompt(prData, diff, commits) {
    const maxDiffLength = 8000; // Limit diff length for token management
    const truncatedDiff =
      diff.length > maxDiffLength
        ? diff.substring(0, maxDiffLength) + "\n\n... (diff truncated)"
        : diff;

    let prompt = `Please analyze this pull request and provide a comprehensive summary.

**Pull Request Information:**
- Title: ${prData.title}
- Author: ${prData.user?.login || "Unknown"}
- Status: ${prData.state}
- Files Changed: ${prData.changed_files || "Unknown"}
- Additions: ${prData.additions || 0}
- Deletions: ${prData.deletions || 0}`;

    if (prData.body && prData.body.trim()) {
      prompt += `\n- Description: ${prData.body}`;
    }

    if (commits && commits.length > 0) {
      prompt += `\n\n**Commits (${commits.length}):**\n`;
      commits.forEach((commit, index) => {
        if (index < 10) {
          // Limit to first 10 commits to manage token usage
          prompt += `- ${commit.sha}: ${commit.message} (by ${commit.author})\n`;
        }
      });
      if (commits.length > 10) {
        prompt += `... and ${commits.length - 10} more commits\n`;
      }
    }

    prompt += `\n\n**Code Changes:**
\`\`\`diff
${truncatedDiff}
\`\`\`

Please provide:
1. **Summary**: A clear overview of what this PR accomplishes
2. **Key Changes**: The main technical changes made
3. **Impact**: How these changes affect the codebase
4. **Changelog**: Structured list of changes suitable for release notes

Format your response in clear markdown with appropriate sections.`;

    return prompt;
  }

  /**
   * Create fallback summary when AI generation fails
   */
  _createFallbackSummary(prData, commits) {
    const { conventionalCommits, regularCommits } =
      this._parseConventionalCommits(commits || []);
    const hasConventionalCommits = conventionalCommits.length > 0;

    let summary = `## Summary\n\nThis pull request includes ${
      commits?.length || 0
    } commit(s)`;

    if (prData.changed_files) {
      summary += ` affecting ${prData.changed_files} file(s)`;
    }

    if (prData.additions || prData.deletions) {
      summary += ` with ${prData.additions || 0} additions and ${
        prData.deletions || 0
      } deletions`;
    }

    summary += ".\n\n";

    if (prData.body && prData.body.trim() !== "") {
      summary += `**Description:** ${prData.body}\n\n`;
    }

    let changelog = "## Changes\n\n";

    if (hasConventionalCommits) {
      changelog += this._formatConventionalCommits(conventionalCommits);
      if (regularCommits.length > 0) {
        changelog += "\n" + this._formatRegularCommits(regularCommits);
      }
    } else if (regularCommits.length > 0) {
      changelog += this._formatRegularCommits(regularCommits);
    } else {
      changelog += "- Changes made to the codebase\n";
    }

    return summary + changelog;
  }

  /**
   * Parse conventional commits from commit messages
   */
  _parseConventionalCommits(commits) {
    const conventionalCommits = [];
    const regularCommits = [];

    if (!Array.isArray(commits)) {
      logger.warn("Commits is not an array:", typeof commits);
      return { conventionalCommits: [], regularCommits: [] };
    }

    const CONVENTIONAL_COMMIT_REGEX = /^(\w+)(\(.+\))?:\s*(.+)$/;

    commits.forEach((commit, index) => {
      try {
        if (!commit || typeof commit !== "object") {
          logger.warn(`Commit at index ${index} is invalid:`, commit);
          return;
        }

        if (!commit.message || typeof commit.message !== "string") {
          logger.warn(`Commit at index ${index} has invalid message:`, commit);
          return;
        }

        const message = commit.message.split("\n")[0];
        const match = message.match(CONVENTIONAL_COMMIT_REGEX);

        if (match) {
          const [, type, scope, description] = match;
          if (type && description) {
            conventionalCommits.push({
              type: type,
              scope: scope ? scope.slice(1, -1) : null,
              description: description,
              originalMessage: message,
              sha: commit.sha || "unknown",
              author: commit.author || "unknown",
            });
          } else {
            regularCommits.push({
              message: message,
              sha: commit.sha || "unknown",
              author: commit.author || "unknown",
            });
          }
        } else {
          regularCommits.push({
            message: message,
            sha: commit.sha || "unknown",
            author: commit.author || "unknown",
          });
        }
      } catch (error) {
        logger.error(
          `Error processing commit at index ${index}:`,
          error.message
        );
      }
    });

    logger.debug(
      `Parsed ${conventionalCommits.length} conventional commits and ${regularCommits.length} regular commits`
    );

    return { conventionalCommits, regularCommits };
  }

  /**
   * Format conventional commits for display
   */
  _formatConventionalCommits(conventionalCommits) {
    if (conventionalCommits.length === 0) return "";

    const CONVENTIONAL_COMMIT_TYPES = {
      feat: "Features",
      fix: "Bug Fixes",
      docs: "Documentation",
      style: "Code Style",
      refactor: "Code Refactoring",
      perf: "Performance Improvements",
      test: "Tests",
      chore: "Maintenance",
      ci: "CI/CD",
      build: "Build System",
    };

    const groupedByType = conventionalCommits.reduce((acc, commit) => {
      if (commit && commit.type) {
        if (!acc[commit.type]) {
          acc[commit.type] = [];
        }
        acc[commit.type].push(commit);
      }
      return acc;
    }, {});

    let formatted = "### Changes by Type\n\n";

    Object.entries(groupedByType).forEach(([type, commits]) => {
      if (type && commits && commits.length > 0) {
        const changeType =
          CONVENTIONAL_COMMIT_TYPES[type] || type.toUpperCase();
        formatted += `**${changeType}:**\n`;
        commits.forEach((commit) => {
          if (commit && commit.description) {
            const scope = commit.scope ? `(${commit.scope}) ` : "";
            formatted += `- ${scope}${commit.description} (${commit.sha})\n`;
          }
        });
        formatted += "\n";
      }
    });

    return formatted;
  }

  /**
   * Format regular commits for display
   */
  _formatRegularCommits(regularCommits) {
    if (regularCommits.length === 0) return "";

    let formatted = "### Other Changes\n\n";
    regularCommits.forEach((commit) => {
      formatted += `- ${commit.message} (${commit.sha})\n`;
    });

    return formatted;
  }
}

export const prService = new PRService();
