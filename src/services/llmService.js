import { config } from "../config/index.js";
import {
  CONVENTIONAL_COMMIT_REGEX,
  CONVENTIONAL_COMMIT_TYPES,
  PR_CONSTANTS,
} from "../utils/constants.js";
import { createLogger } from "../utils/logger.js";

const logger = createLogger("LLMService");

export class LLMService {
  constructor() {
    this.baseUrl = config.api.copilotBaseUrl;
  }

  async generatePRSummary(prData, diff, commits = [], token) {
    try {
      logger.debug(`Generating summary for PR: ${prData.title}`);

      const prompt = this._createSummaryPrompt(prData, diff, commits);

      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: "POST",
        headers: {
          authorization: `Bearer ${token}`,
          "content-type": "application/json",
        },
        body: JSON.stringify({
          messages: [
            {
              role: "system",
              content:
                "You are a helpful assistant that analyzes code changes and generates clear, professional summaries and changelog entries. You understand conventional commits and can create well-structured changelogs.",
            },
            {
              role: "user",
              content: prompt,
            },
          ],
          stream: false,
        }),
      });

      if (!response.ok) {
        throw new Error(
          `GitHub LLM API error: ${response.status} ${response.statusText}`
        );
      }

      const data = await response.json();
      const generatedContent = data.choices[0]?.message?.content;

      if (!generatedContent) {
        throw new Error("No content generated by LLM");
      }

      logger.info("Successfully generated PR summary");
      return generatedContent;
    } catch (error) {
      logger.error("Failed to generate PR summary:", error.message);
      return this._createErrorSummary(error.message);
    }
  }

  async streamChatCompletion(messages, token) {
    try {
      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: "POST",
        headers: {
          authorization: `Bearer ${token}`,
          "content-type": "application/json",
        },
        body: JSON.stringify({
          messages,
          stream: true,
        }),
      });

      if (!response.ok) {
        throw new Error(
          `GitHub LLM API error: ${response.status} ${response.statusText}`
        );
      }

      return response;
    } catch (error) {
      logger.error("Failed to stream chat completion:", error.message);
      throw error;
    }
  }

  _parseConventionalCommits(commits) {
    const conventionalCommits = [];
    const regularCommits = [];

    // Add safety check for commits array
    if (!Array.isArray(commits)) {
      logger.warn("Commits is not an array:", typeof commits);
      return { conventionalCommits: [], regularCommits: [] };
    }

    commits.forEach((commit, index) => {
      try {
        // Safety check for commit object
        if (!commit || typeof commit !== "object") {
          logger.warn(`Commit at index ${index} is invalid:`, commit);
          return;
        }

        // Safety check for commit message
        if (!commit.message || typeof commit.message !== "string") {
          logger.warn(`Commit at index ${index} has invalid message:`, commit);
          return;
        }

        const message = commit.message.split("\n")[0];
        const match = message.match(CONVENTIONAL_COMMIT_REGEX);

        if (match) {
          const [, type, scope, description] = match;
          // Only add if type and description are defined
          if (type && description) {
            conventionalCommits.push({
              type: type,
              scope: scope ? scope.slice(1, -1) : null,
              description: description,
              originalMessage: message,
              sha: commit.sha || "unknown",
              author: commit.author || "unknown",
            });
          } else {
            // Treat as regular commit if parsing failed
            logger.debug(`Conventional commit parsing failed for: ${message}`);
            regularCommits.push({
              message: message,
              sha: commit.sha || "unknown",
              author: commit.author || "unknown",
            });
          }
        } else {
          regularCommits.push({
            message: message,
            sha: commit.sha || "unknown",
            author: commit.author || "unknown",
          });
        }
      } catch (error) {
        logger.error(
          `Error processing commit at index ${index}:`,
          error.message
        );
        logger.error("Commit data:", commit);
      }
    });

    logger.debug(
      `Parsed ${conventionalCommits.length} conventional commits and ${regularCommits.length} regular commits`
    );
    return { conventionalCommits, regularCommits };
  }

  _formatConventionalCommits(conventionalCommits) {
    if (conventionalCommits.length === 0) return "";

    const groupedByType = conventionalCommits.reduce((acc, commit) => {
      // Ensure commit has a valid type
      if (commit && commit.type) {
        if (!acc[commit.type]) {
          acc[commit.type] = [];
        }
        acc[commit.type].push(commit);
      }
      return acc;
    }, {});

    let formatted = "Conventional Commits:\n";
    Object.entries(groupedByType).forEach(([type, commits]) => {
      // Additional safety check
      if (type && commits && commits.length > 0) {
        const changeType =
          CONVENTIONAL_COMMIT_TYPES[type] || type.toUpperCase();
        formatted += `\n${changeType}:\n`;
        commits.forEach((commit) => {
          if (commit && commit.description) {
            const scope = commit.scope ? `(${commit.scope}) ` : "";
            formatted += `- ${scope}${commit.description} (${commit.sha})\n`;
          }
        });
      }
    });

    return formatted;
  }

  _formatRegularCommits(regularCommits) {
    if (regularCommits.length === 0) return "";

    let formatted = "Other Commits:\n";
    regularCommits.forEach((commit) => {
      formatted += `- ${commit.message} (${commit.sha})\n`;
    });

    return formatted;
  }

  _createSummaryPrompt(prData, diff, commits) {
    try {
      logger.debug(
        `Creating summary prompt with ${commits?.length || 0} commits`
      );

      const truncatedDiff =
        diff && diff.length > PR_CONSTANTS.MAX_DIFF_LENGTH
          ? `${diff.slice(0, PR_CONSTANTS.MAX_DIFF_LENGTH)}\n... (truncated)`
          : diff || "No diff provided";

      const { conventionalCommits, regularCommits } =
        this._parseConventionalCommits(commits || []);
      const conventionalCommitsFormatted =
        this._formatConventionalCommits(conventionalCommits);
      const regularCommitsFormatted =
        this._formatRegularCommits(regularCommits);

      const hasConventionalCommits = conventionalCommits.length > 0;
      const commitsLength = Array.isArray(commits) ? commits.length : 0;

      return `Please analyze this pull request and generate:

1. **Summary**: A concise summary of what this PR does
2. **Changelog**: A well-structured changelog entry

PR Details:
- Title: ${prData.title}
- Description: ${prData.body || "No description provided"}
- Files changed: ${prData.changed_files}
- Additions: ${prData.additions}
- Deletions: ${prData.deletions}
- Number of commits: ${commitsLength}

${conventionalCommitsFormatted}
${regularCommitsFormatted}

Code Changes (Diff):
\`\`\`
${truncatedDiff}
\`\`\`

Please format your response as:

## Summary
[Provide a clear, concise summary of what this PR accomplishes based on the commits and code changes]

## Changelog
${
  hasConventionalCommits
    ? `[Create a structured changelog using the conventional commit format. Group changes by type (Added, Fixed, Changed, etc.). Use the commit messages and code diff to provide clear, user-facing descriptions.]`
    : `[Create a changelog based on the commit messages and code changes. Focus on user-facing changes and improvements.]`
}

Guidelines:
- Focus on user-facing changes and business value
- Use the commit messages as the primary source for the changelog
- Supplement with insights from the code diff when needed
- Keep changelog entries clear and actionable
- Group similar changes together
${
  hasConventionalCommits
    ? "- Follow conventional commit categorization (Added, Fixed, Changed, etc.)"
    : "- Use logical grouping for non-conventional commits"
}`;
    } catch (error) {
      logger.error("Error creating summary prompt:", error.message);
      return "Error creating summary prompt. Please check the input data.";
    }
  }

  _createErrorSummary(errorMessage) {
    return `## Summary
Error generating summary: ${errorMessage}

## Changelog
Unable to generate changelog due to error.`;
  }
}

export const llmService = new LLMService();
