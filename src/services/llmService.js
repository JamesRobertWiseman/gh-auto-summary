import { config } from "../config/index.js";
import {
  CONVENTIONAL_COMMIT_REGEX,
  CONVENTIONAL_COMMIT_TYPES,
  PR_CONSTANTS,
} from "../utils/constants.js";
import { createLogger } from "../utils/logger.js";

const logger = createLogger("LLMService");

export class LLMService {
  constructor() {
    this.baseUrl = config.api.copilotBaseUrl;
  }

  async generatePRSummary(prData, diff, commits = [], token) {
    try {
      logger.debug(`Generating summary for PR: ${prData.title}`);

      const prompt = this._createSummaryPrompt(prData, diff, commits);

      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: "POST",
        headers: {
          authorization: `Bearer ${token}`,
          "content-type": "application/json",
        },
        body: JSON.stringify({
          messages: [
            {
              role: "system",
              content:
                "You are a helpful assistant that analyzes code changes and generates clear, professional summaries and changelog entries. You understand conventional commits and can create well-structured changelogs.",
            },
            {
              role: "user",
              content: prompt,
            },
          ],
          stream: false,
        }),
      });

      if (!response.ok) {
        throw new Error(
          `GitHub LLM API error: ${response.status} ${response.statusText}`
        );
      }

      const data = await response.json();
      const generatedContent = data.choices[0]?.message?.content;

      if (!generatedContent) {
        throw new Error("No content generated by LLM");
      }

      logger.info("Successfully generated PR summary");
      return generatedContent;
    } catch (error) {
      logger.error("Failed to generate PR summary:", error.message);
      return this._createErrorSummary(error.message);
    }
  }

  async streamChatCompletion(messages, token) {
    try {
      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: "POST",
        headers: {
          authorization: `Bearer ${token}`,
          "content-type": "application/json",
        },
        body: JSON.stringify({
          messages,
          stream: true,
        }),
      });

      if (!response.ok) {
        throw new Error(
          `GitHub LLM API error: ${response.status} ${response.statusText}`
        );
      }

      return response;
    } catch (error) {
      logger.error("Failed to stream chat completion:", error.message);
      throw error;
    }
  }

  _parseConventionalCommits(commits) {
    const conventionalCommits = [];
    const regularCommits = [];

    commits.forEach((commit) => {
      const message = commit.message.split("\n")[0];
      const match = message.match(CONVENTIONAL_COMMIT_REGEX);

      if (match) {
        const [, type, scope, description] = match;
        conventionalCommits.push({
          type: type,
          scope: scope ? scope.slice(1, -1) : null,
          description: description,
          originalMessage: message,
          sha: commit.sha,
          author: commit.author,
        });
      } else {
        regularCommits.push({
          message: message,
          sha: commit.sha,
          author: commit.author,
        });
      }
    });

    return { conventionalCommits, regularCommits };
  }

  _formatConventionalCommits(conventionalCommits) {
    if (conventionalCommits.length === 0) return "";

    const groupedByType = conventionalCommits.reduce((acc, commit) => {
      if (!acc[commit.type]) {
        acc[commit.type] = [];
      }
      acc[commit.type].push(commit);
      return acc;
    }, {});

    let formatted = "Conventional Commits:\n";
    Object.entries(groupedByType).forEach(([type, commits]) => {
      const changeType = CONVENTIONAL_COMMIT_TYPES[type] || type.toUpperCase();
      formatted += `\n${changeType}:\n`;
      commits.forEach((commit) => {
        const scope = commit.scope ? `(${commit.scope}) ` : "";
        formatted += `- ${scope}${commit.description} (${commit.sha})\n`;
      });
    });

    return formatted;
  }

  _formatRegularCommits(regularCommits) {
    if (regularCommits.length === 0) return "";

    let formatted = "Other Commits:\n";
    regularCommits.forEach((commit) => {
      formatted += `- ${commit.message} (${commit.sha})\n`;
    });

    return formatted;
  }

  _createSummaryPrompt(prData, diff, commits) {
    const truncatedDiff =
      diff.length > PR_CONSTANTS.MAX_DIFF_LENGTH
        ? `${diff.slice(0, PR_CONSTANTS.MAX_DIFF_LENGTH)}\n... (truncated)`
        : diff;

    const { conventionalCommits, regularCommits } =
      this._parseConventionalCommits(commits);
    const conventionalCommitsFormatted =
      this._formatConventionalCommits(conventionalCommits);
    const regularCommitsFormatted = this._formatRegularCommits(regularCommits);

    const hasConventionalCommits = conventionalCommits.length > 0;

    return `Please analyze this pull request and generate:

1. **Summary**: A concise summary of what this PR does
2. **Changelog**: A well-structured changelog entry

PR Details:
- Title: ${prData.title}
- Description: ${prData.body || "No description provided"}
- Files changed: ${prData.changed_files}
- Additions: ${prData.additions}
- Deletions: ${prData.deletions}
- Number of commits: ${commits.length}

${conventionalCommitsFormatted}
${regularCommitsFormatted}

Code Changes (Diff):
\`\`\`
${truncatedDiff}
\`\`\`

Please format your response as:

## Summary
[Provide a clear, concise summary of what this PR accomplishes based on the commits and code changes]

## Changelog
${
  hasConventionalCommits
    ? `[Create a structured changelog using the conventional commit format. Group changes by type (Added, Fixed, Changed, etc.). Use the commit messages and code diff to provide clear, user-facing descriptions.]`
    : `[Create a changelog based on the commit messages and code changes. Focus on user-facing changes and improvements.]`
}

Guidelines:
- Focus on user-facing changes and business value
- Use the commit messages as the primary source for the changelog
- Supplement with insights from the code diff when needed
- Keep changelog entries clear and actionable
- Group similar changes together
${
  hasConventionalCommits
    ? "- Follow conventional commit categorization (Added, Fixed, Changed, etc.)"
    : "- Use logical grouping for non-conventional commits"
}`;
  }

  _createErrorSummary(errorMessage) {
    return `## Summary
Error generating summary: ${errorMessage}

## Changelog
Unable to generate changelog due to error.`;
  }
}

export const llmService = new LLMService();
