import { config } from "../config/index.js";
import { createLogger } from "../utils/logger.js";

const logger = createLogger("CopilotClientService");

export class CopilotClientService {
  constructor() {
    this.baseUrl = config.ai.copilot.baseUrl;
  }

  /**
   * Generate a PR summary using the Copilot API
   * This method simulates being called from within a Copilot Extension context
   * @param {object} prData - Pull request data
   * @param {string} diff - PR diff
   * @param {array} commits - PR commits
   * @param {string} installationToken - GitHub App installation token
   * @returns {Promise<string>} The generated summary
   */
  async generatePRSummary(prData, diff, commits, installationToken) {
    try {
      logger.info("Generating PR summary using Copilot Extension API");

      // For webhook-triggered requests, we need to create a synthetic token
      // that can be used with the Copilot API
      const copilotToken = await this._getCopilotToken(installationToken);

      const prompt = this._createSummaryPrompt(prData, diff, commits);

      const response = await this._makeCompletionRequest(prompt, copilotToken);

      logger.info("Successfully generated PR summary via Copilot API");
      return response;
    } catch (error) {
      logger.error(
        "Failed to generate PR summary via Copilot API:",
        error.message
      );
      throw error;
    }
  }

  /**
   * Get a token that can be used with the Copilot API
   * In a real implementation, this would involve proper OIDC token exchange
   * @param {string} installationToken - GitHub App installation token
   * @returns {Promise<string>} Token for Copilot API
   */
  async _getCopilotToken(installationToken) {
    try {
      // Method 1: Try to use the installation token directly
      // (This may not work as Copilot API typically requires user tokens)
      logger.debug("Attempting to use installation token with Copilot API");
      return installationToken;

      // TODO: Implement proper OIDC token exchange flow
      // This would involve:
      // 1. Creating an OIDC identity token
      // 2. Exchanging it for a Copilot-compatible token
      // 3. Using that token for API requests
    } catch (error) {
      logger.error("Failed to get Copilot token:", error.message);
      throw error;
    }
  }

  /**
   * Make a completion request to the Copilot API
   * @param {string} prompt - The prompt to send
   * @param {string} token - The authentication token
   * @returns {Promise<string>} The completion response
   */
  async _makeCompletionRequest(prompt, token) {
    try {
      logger.debug("Making completion request to Copilot API");

      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
          "User-Agent": "GitHub-Auto-Summary-Extension/1.0",
        },
        body: JSON.stringify({
          messages: [
            {
              role: "system",
              content:
                "You are a helpful assistant that analyzes code changes and generates clear, professional summaries and changelog entries. You understand conventional commits and can create well-structured changelogs.",
            },
            {
              role: "user",
              content: prompt,
            },
          ],
          stream: false,
          max_tokens: 2000,
        }),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        logger.error(
          `Copilot API error: ${response.status} ${response.statusText}`
        );
        logger.error("Error body:", errorBody);

        // If the token doesn't work with Copilot API, we can fall back
        if (response.status === 401 || response.status === 403) {
          throw new Error("COPILOT_AUTH_FAILED");
        }

        throw new Error(
          `GitHub Copilot API error: ${response.status} ${response.statusText} - ${errorBody}`
        );
      }

      const data = await response.json();
      const content = data.choices[0]?.message?.content;

      if (!content) {
        throw new Error("No content generated by GitHub Copilot API");
      }

      return content;
    } catch (error) {
      // If it's a Copilot auth failure, we can indicate fallback is needed
      if (error.message === "COPILOT_AUTH_FAILED") {
        logger.warn(
          "Copilot API authentication failed - installation tokens may not be supported"
        );
        throw error;
      }

      logger.error("Copilot API request failed:", error.message);
      throw error;
    }
  }

  /**
   * Create a detailed prompt for PR summary generation
   * @param {object} prData - PR data
   * @param {string} diff - PR diff
   * @param {array} commits - PR commits
   * @returns {string} The formatted prompt
   */
  _createSummaryPrompt(prData, diff, commits) {
    const commitsList = commits
      .map((c) => `- ${c.message} (${c.sha})`)
      .join("\n");

    // Truncate diff if too long
    const maxDiffLength = 8000;
    const truncatedDiff =
      diff && diff.length > maxDiffLength
        ? `${diff.slice(0, maxDiffLength)}\n... (truncated)`
        : diff || "No diff provided";

    return `Please analyze this pull request and generate a comprehensive summary and changelog.

**Pull Request Details:**
- Title: ${prData.title}
- Description: ${prData.body || "No description provided"}
- Files changed: ${prData.changed_files || 0}
- Additions: ${prData.additions || 0}
- Deletions: ${prData.deletions || 0}
- Commits: ${commits.length}

**Commits:**
${commitsList}

**Code Changes (Diff):**
\`\`\`diff
${truncatedDiff}
\`\`\`

Please provide:

## Summary
A clear, concise summary of what this PR accomplishes, focusing on the business value and user-facing changes.

## Changelog
A well-structured changelog entry that categorizes changes appropriately. If the commits follow conventional commit format, group them by type (feat, fix, docs, etc.). Otherwise, create logical groupings.

Guidelines:
- Focus on user-facing changes and improvements
- Use clear, actionable language
- Group related changes together
- Include relevant technical details without being overly verbose`;
  }

  /**
   * Create a simulated Copilot Extension request for testing
   * This method can be used to test the Copilot API integration
   * @param {string} message - The message to send
   * @param {string} token - The authentication token
   * @returns {Promise<string>} The response
   */
  async simulateCopilotChat(message, token) {
    try {
      logger.debug("Simulating Copilot chat request");

      const response = await this._makeCompletionRequest(message, token);
      return response;
    } catch (error) {
      logger.error("Copilot chat simulation failed:", error.message);
      throw error;
    }
  }

  /**
   * Check if the Copilot API is accessible with the given token
   * @param {string} token - The authentication token to test
   * @returns {Promise<boolean>} Whether the API is accessible
   */
  async checkCopilotAPIAccess(token) {
    try {
      logger.debug("Checking Copilot API access");

      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
          "User-Agent": "GitHub-Auto-Summary-Extension/1.0",
        },
        body: JSON.stringify({
          messages: [
            {
              role: "user",
              content: "Test message",
            },
          ],
          stream: false,
          max_tokens: 10,
        }),
      });

      if (response.ok) {
        logger.info("Copilot API access confirmed");
        return true;
      } else {
        logger.warn(
          `Copilot API access failed: ${response.status} ${response.statusText}`
        );
        return false;
      }
    } catch (error) {
      logger.warn("Copilot API access check failed:", error.message);
      return false;
    }
  }
}

export const copilotClientService = new CopilotClientService();
